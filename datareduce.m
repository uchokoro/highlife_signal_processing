function [error_message, tempo] = datareduce(audio_infile, overlap, pow)

% DATAREDUCE Analyzes audio_infile and extracts its tempo 
% DATAREDUCE(INFILE,OVERLAP,POW) 
%% audio_infile=name of .wav or .au file to process 
%% overlap = the overlap of the sliding window 
%% pow = exponent: uses 2^pow samples to compute the FFT. The values are 9, 10, 11, or 14. 
%% This program applies filters generated by Anthony U. Okoro
%%%% Written By Joseph E. Flannick, Rachel Hall and Adlai Waksman
%%%% Modified by Anthony U. Okoro

[path,infile,ext]=fileparts(audio_infile); 
sep = filesep;
soundfile_error_string = 'Audio file must be in .au or .wav format.';

% set default audio filepath
if isempty(path)
    path=[sep, 'home', sep, 'Desktop', sep, 'antonio', sep, 'highlife tracks', sep, 'docs', sep, 'rhythmic integrity', sep, 'software', sep,'test audio'];  
end

% set default audio file extension
if isempty(ext)
ext = '.wav'; 
end

% Confirm that input audio is the correct format. Return error code if it is not. 
if (not(strcmpi(ext, '.au')) && not(strcmpi(ext, '.wav'))) 
error_message = soundfile_error_string;
return
end

au = 0; 
if length(ext) == 3 
au = 1; 
end

clear soundfile_error_string %release memory

% ------- READ IN THE AUDIO FILE AND SET UP -------
% fullfile = input file name. It has 2 rows (stereo). 
fullfile=[path,sep,infile,ext];

% selects the appropriate size matrix (filtmat) that will separate out frequency bands. 
if au==1

try
[signal, fs, bits]=auread(fullfile); % read the input .au file
catch ME
error_message = ME.message;
return
end

else

try
[signal, fs, bits]=wavread(fullfile); % read the input .wav file
catch ME
error_message = ME.message;
return
end

end

clear aufullfile % release memory!
temp_signal = signal; % store the contents of signal in a temporary matrix
signal(:,1) = round(mean(temp_signal, 2)); %get the average of the stereo tracks to form a mono track. Store this in the first column/channel of signal
signal(:, 2) = []; % strip off second column/channel of the signal to make it mono track 
cleartemp_signal % release memory
nfft = 2^pow; % length of FFT 
ns = length(signal); % total number of samples in (length of) the audio file (signal)
ncol = floor ((ns-nfft) / (nfft - overlap)); % number of cols in audmat, sigmatrixetc
sigmatrix = zeros(nfft, ncol); % create our signal matrix 
colindex = 1 + (0:(ncol-1)) * (nfft - overlap); % set up the column indexing 
rowindex(:,1) = (1:nfft); % set up the row indexing 

if ns < (nfft + colindex(ncol)-1) % if samples are smaller than signal matrix size
signal(nfft+colindex(ncol)-1) = 0; % zero-pad the signal 
end

window=hann(nfft); % hanning window vector of size nfft

% ------- CREATE THE AUDIO MATRIX -------
% shove the signal into a matrix 
sigmatrix(:) = signal(rowindex(:, ones(1, ncol)) + colindex(ones(nfft, 1), :) - 1);
clear rowindex colindex signal % relieve memory usage!! 
winmatrix = window(:, ones(1, ncol)); % create a window matrix so we can multiply 
clear window % relieve memory usage!!

% take the fft across the 1st dimension (columns) of the matrix 
fftmat = fft(winmatrix.*sigmatrix, [], 1); 
clearsigmatrixwinmatrix % relieve memory usage!!

% get rid of 1/2 the rows b/c they are symmetric 
fftmat = fftmat(1:(nfft/2), :); 
fftmag = abs(fftmat); % use the magnitudes of the fft
clearfftmat % relieve memory usage!!

% create the filter matrix to enable separating fftmag into frequency bands
try

switch pow
case 9
rowfilt = 21;
case 10
rowfilt=23;
case 14
rowfilt=29;
otherwise
error('The value used for pow  is not supported. Only the values 9, 10, 11 and 14 are supported');
end

catch ME
error_message = ME.message;
return
end

filtwin = floor(nfft/(2*rowfilt));
filtcolind = (0:nfft/2 - 1);
filnd = zeros(rowfilt,filtwin);

for i = 1:rowfilt

for j=1:filtwin
filnd(i,j) = i;
end

end

filnd = filnd';
filtrowind = zeros(1, rowfilt*filtwin);
filtrowind(:) = filnd(1:rowfilt*filtwin);
filtrowind(rowfilt*filtwin + 1: nfft/2) = rowfilt;
clear filnd;
filtmatind = zeros(1, nfft/2); % index vector for filter matrix creation
filtmatind(:) = ((filtcolind*rowfilt) + filtrowind);
filtmat = zeros(rowfilt, nfft/2); % filter matrix
filtmat(filtmatind) = 1;

% create the audio matrix by applying the filter 
audmat = filtmat * fftmag; 
clear fftmag % relieve memory usage!!

% ------- EXTRACT THE TEMPO ------- 
duration=ns/fs; %duration of audio file in seconds
[raud,caud]=size(audmat); 
lenpiece=round(caud/2); % lenpiece is half the % number of columns in audmat
dftaud = abs(fft(audmat, [], 2)); % create the dft matrix  
dftaud = dftaud(:, 1:lenpiece+1);
[peak,indx]= max(max(dftaud(:,floor(3*duration):end)));
indx=round((indx+floor(3*duration))/2); 
tempo = round(60*indx/duration);
error_message = 0;
clear audmat dftaud % free memory